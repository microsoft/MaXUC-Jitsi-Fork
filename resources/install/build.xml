<?xml version="1.0"?>
<!-- Portions (c) Microsoft Corporation. All rights reserved. -->
<!--
   The install scripts are located inside the resources/install directory . The
   files are separated in subdirectories according to distribution - generic,
   linux, windows, macosx.
-->
<project name="jitsi-installer" basedir="." default="ant-usage">

    <import file="../../build.xml"/>

    <!-- The directory where plugins are located in -->
    <property name="plugins" value="${ext}/plugins"/>

    <import file="${inst.resrc}/custom-installer-build-targets.xml"/>

    <!-- Load installer properties -->
    <!-- USERS NEED TO UPDATE THIS FILE -->
    <property file="${inst.resrc}/installers.properties"/>

    <target name="-windows-installer-plugin">
        <basename property="plugin-name" file="${plugin-location}" />
        <echo message="=== Executing Windows installer step for ${plugin-name} ====" />
        <ant dir="${plugin-location}" antfile="build.xml" target="windows-installer">
            <property name="wix.app.dir" value="${windows.app.dir}/tmp/light" />
            <property environment="env" />
        </ant>
    </target>

    <target name="-macosx-installer-plugin">
        <basename property="plugin-name" file="${plugin-location}" />
        <echo message="=== Executing Mac installer step for ${plugin-name} ====" />
        <ant dir="${plugin-location}" antfile="build.xml" target="macosx-installer">
            <property name="macosx.app.dir" value="${macosx.app.dir}" />
            <property environment="env" />
        </ant>
    </target>

    <target name="load-properties">
        <!-- load properties on demand here so it can evaluate
        any sip-communicator.version property from property file
        Since properties are immutable, the first file to set the value is the one that counts,
        so load the overriders first -->
        <property file="${inst.resrc}/ant-build-config-overrides.properties"/>
        <property file="${credentials}/macosx/macosx-sign.properties"/>
        <property file="${inst.resrc}/ant-build-config.properties"/>

        <!-- If the old app name property isn't already set, use a default of "" -->
    	<property name="application.oldname.ascii" value="" />

        <!--
            Provide access to the environment variables via the prefix "env."
            because we will modify at least the PATH where is needed.
        -->
        <property environment="env" />

        <!-- Display the properties - essential to understand the build process -->
        <echoproperties/>
    </target>

    <!-- Put here the Windows release directory -->
    <property name="windows.app.dir" value="${sc.basedir}/${release}/windows"/>

    <!-- The path to the dh_testdir tool -->
    <property name="dh_testdir" value="/usr/bin/dh_testdir"/>

    <!-- Put here the release directory -->
    <property name="macosx.app.dir" value="${release}/macosx"/>
    <!-- Put here the resource directory -->
    <property name="macosx.resrc.dir" value="${inst.resrc}/macosx"/>

    <!-- default Ant target does nothing except print helpful options -->
    <target name="ant-usage"
            description="simply execute 'ant' to discover the most useful targets.">
        <echo message="Useful ant commands for the Jitsi Build Installer..." />
        <echo message="'ant build-installation-wix' for building Windows x64 MSI installation file using WiX" />
    </target>

    <target name="clean-install-windows">
        <delete dir="${windows.app.dir}"/>
        <mkdir dir="${windows.app.dir}"/>
        <mkdir dir="${windows.app.dir}/tmp"/>
    </target>

    <target name="build-installation-wix"
            depends="version,load-properties">
        <property name="windows_native_path" value="${sc.basedir}\lib\native\windows-64"/>
        <property name="windows.jre.arch.file" value=""/>
        <condition property="windows.jre.arch.zip" value="${windows.jre.zip}">
            <isset property="windows.jre.zip" />
        </condition>
        <property name="windows.download.link" value="${link.download.windows64}"/>
        <property name="windows.package.name.suffix" value="x64.exe"/>
        <property name="windows.msi.package.name.suffix" value="x64.msi"/>
        <property name="windows.arch" value="64"/>
        <property name="mingw.home" value="C:/mingw/x64" />
        <antcall target="build-installation-wix-base" />
    </target>

    <target name="unzip-windows-jre" if="windows.jre.arch.zip.isset">
        <unzip
                src="${unzip.windows.jre.src}"
                dest="${unzip.windows.jre.dest}" />
        <property name="unzip.windows.jre.dir" value="" />
        <delete failonerror="false" includeemptydirs="true" quiet="true">
            <fileset
                    casesensitive="false"
                    defaultexcludes="false"
                    dir="${unzip.windows.jre.dest}/jre">
                <include name="bin/rmid.exe" />
                <include name="bin/rmiregistry.exe" />
                <include name="bin/tnameserv.exe" />
                <include name="bin/keytool.exe" />
                <include name="bin/kinit.exe" />
                <include name="bin/klist.exe" />
                <include name="bin/ktab.exe" />
                <include name="bin/policytool.exe" />
                <include name="bin/orbd.exe" />
                <include name="bin/servertool.exe" />
                <include name="bin/javaws.exe" />
                <include name="lib/javaws.jar" />
                <include name="lib/javaws/**" />
                <include name="bin/javacpl.exe" />
                <include name="bin/jucheck.exe" />
                <include name="bin/jusched.exe" />
                <include name="bin/wsdetect.dll" />
                <include name="bin/npjpi*.dll" />
                <include name="bin/npjava11.dll" />
                <include name="bin/npjava12.dll" />
                <include name="bin/npjava13.dll" />
                <include name="bin/npjava14.dll" />
                <include name="bin/npjava32.dll" />
                <include name="bin/npoji610.dll" />
                <include name="bin/regutils.dll" />
                <include name="bin/axbridge.dll" />
                <include name="bin/deploy.dll" />
                <include name="bin/jpicom.dll" />
                <include name="bin/javacpl.cpl" />
                <include name="bin/jpiexp.dll" />
                <include name="bin/jpinscp.dll" />
                <include name="bin/jpioji.dll" />
                <include name="bin/jpishare.dll" />
                <include name="lib/deploy.jar" />
                <include name="lib/plugin.jar" />

                <include name="bin/new_plugin/**" />
                <include name="bin/jp2*.exe" />
                <include name="lib/deploy/**" />
                <include name="bin/jqs*.exe" />
            </fileset>
        </delete>

        <!-- generating the customised font configuration file from the original default file in JDK. -->
        <mkdir dir="${unzip.windows.jre.dest}/jre/conf/fonts" />
        <exec executable="sed" output="${unzip.windows.jre.dest}/jre/conf/fonts/fontconfig.properties" logError="true" failonerror="true">
            <arg value="-E"/>
            <arg value="s/(allfonts\.thai)=DokChampa/\1=Leelawadee UI/g;s/(sansserif\.[a-z]+\.alphabetic)=Arial/\1=Segoe UI/g;s/^(filename\.Segoe_UI_Symbol=SEGUISYM.TTF)$/\1\n\nfilename.Segoe_UI=segoeui.ttf\nfilename.Segoe_UI_Bold=segoeuib.ttf\nfilename.Segoe_UI_Italic=segoeuii.ttf\nfilename.Segoe_UI_Bold_Italic=segoeuiz.ttf/g"/>
            <arg value="${unzip.windows.jre.dest}/jre/lib/fontconfig.properties.src"/>
        </exec>
    </target>

    <target name="build-installation-wix-base"
            depends="clean-install-windows,buildtools.init-ant-contrib" >
        <property name="windows.package.name"
            value="${package.name}-${sip-communicator.version}-${windows.package.name.suffix}"/>
        <property name="windows.msi.package.name"
            value="${package.name}-${sip-communicator.version}-${windows.msi.package.name.suffix}"/>

        <!--
            This versionupdate.properties file isn't of interest to the MSI but
            is necessary for the site.
        -->
        <propertyfile file="${windows.app.dir}/${filename.updates.windows}">
            <entry key="last_version" value="${sip-communicator.version}" />
            <entry key="download_link"
                   value="${windows.download.link}" />
            <entry key="changes_html" value="updates/index.html" />
        </propertyfile>

        <!-- removes spaces,-,_ and & from app.exe.filename if any -->
        <propertyregex property="app.exe.filename"
            input="${application.name.ascii}"
            regexp="[^\w.]"
            replace=""
            override="true"
            global="true"
            defaultValue="${application.name.ascii}"/>

        <!-- if wix.app.launcher.name is not set use app.exe.filename
            If using wix.app.launcher.name make sure not to use spaces,-,_
            in the name.
        -->
        <condition property="wix.app.launcher.name"
                   value="${app.exe.filename}">
            <not>
                <isset property="wix.app.launcher.name" />
            </not>
        </condition>

        <!--
            Prepare for the execution of heat.exe (which is part of the
            preparation for the execution of candle.exe).
        -->
        <property name="light.dir" value="${windows.app.dir}/tmp/light" />
        <mkdir dir="${light.dir}" />

        <echo message="About to make run.exe with coverage set to ${env.ENABLE_COVERAGE}" />
        <!-- Build run.exe (which is the launcher of the application). -->
        <exec
                dir="${src}/native/windows/run"
                executable="make.exe"
                failonerror="true">
            <env key="PATH" path="${mingw.home}/bin;${env.PATH}" />
            <arg value="PRODUCTNAME=${application.name.ascii}" />
        	<arg value="OLDPRODUCTNAME=${application.oldname.ascii}" />
            <arg value="MINGW_HOME=${mingw.home}" />
            <arg value="TARGET_DIR=${light.dir}" />
            <arg value="PRODUCTBUILDVERSION=${sip-communicator.version}" />
            <arg value="TARGET_BASENAME=${wix.app.launcher.name}" />
            <arg value="ENABLE_COVERAGE=${env.ENABLE_COVERAGE}" />
        </exec>

        <delete>
            <fileset dir="${light.dir}">
                <include name="config.h" />
                <include name="run.res" />
            </fileset>
        </delete>

        <copy todir="${light.dir}" overwrite="true">
            <fileset dir="${inst.resrc}/windows">
                <include name="sc-logo.ico" />
            </fileset>
        </copy>

        <!-- copy any resources that we'd like to be available to the installed client -->
        <copy todir="${light.dir}/resources" overwrite="true">
            <fileset dir="${sc.basedir}/resources/bundle"
                     includes="**/*">
            </fileset>
        </copy>

        <mkdir dir="${light.dir}/lib" />
        <copy todir="${light.dir}/lib" overwrite="true">
            <fileset dir="${sc.basedir}/lib">
                <include name="*.jar" />
            </fileset>
            <fileset dir="${sc.basedir}/lib">
                <include name="felix.client.run.properties" />
            </fileset>
            <fileset dir="${sc.basedir}/lib">
                <include name="jitsi-defaults.properties" />
            </fileset>
            <fileset dir="${sc.basedir}/lib">
                <include name="applicationinsights.json" />
            </fileset>
            <fileset dir="${sc.basedir}/lib">
                <include name="jitsi-default-overrides.properties" />
            </fileset>
            <fileset dir="${sc.basedir}/resources/install">
                <include name="logging.properties" />
            </fileset>
        </copy>

        <!-- Add the windows specific bundle path in the felix.client.run.properties file -->
        <echo file="${light.dir}/lib/felix.client.run.properties"
            append="true">felix.auto.start.14= reference:file:sc-bundles/windows-clean-shutdown.jar
        </echo>

        <mkdir dir="${light.dir}/lib/bundle" />
        <copy todir="${light.dir}/lib/bundle" overwrite="true">
            <fileset dir="${sc.basedir}/lib/bundle">
                <include name="*.jar" />
            </fileset>
        </copy>

        <!-- Bundle in the jacoco runtime agent if we're configured to get coverage from the built client -->
        <if>
            <equals arg1="${env.ENABLE_COVERAGE}" arg2="true"/>
            <then>
                <echo message="ENABLE_COVERAGE is set to true so bundling in org.jacoco.agent-runtime.jar" />
                <copy todir="${light.dir}/lib/bundle" overwrite="true">
                    <fileset dir="${project.basedir}/buildtools">
                        <include name="org.jacoco.agent-runtime.jar" />
                    </fileset>
                </copy>
            </then>
            <else>
                <echo message="Not bundling in org.jacoco.agent-runtime.jar as ENABLE_COVERAGE is not set to true: ${env.ENABLE_COVERAGE}" />
            </else>
        </if>

        <!-- Include Electron client if configured to do so -->
        <runtarget target="windows-electron"/>

        <foreach param="plugin-location" target="-windows-installer-plugin" >
            <path refid="included.plugins" />
        </foreach>

        <mkdir dir="${light.dir}/native" />
        <copy todir="${light.dir}/native" overwrite="true">
            <fileset dir="${windows_native_path}">
                <include name="**" />
            </fileset>
        </copy>
        <mkdir dir="${light.dir}/sc-bundles" />
        <copy todir="${light.dir}/sc-bundles" overwrite="true">
            <fileset dir="${sc.basedir}/sc-bundles">
                <include name="*.jar" />
                <exclude name="*slick.jar" />
            </fileset>
            <fileset dir="${sc.basedir}/sc-bundles/os-specific/windows">
                <include name="*.jar" />
                <exclude name="*slick.jar" />
            </fileset>
        </copy>

        <!--
            Include a private Java Runtime Environment if it has been specified.
        -->
        <condition property="windows.jre.arch.zip.isset">
            <and>
                <isset property="windows.jre.arch.zip" />
                <not>
                    <equals arg1="${windows.jre.arch.zip}" arg2="" />
                </not>
            </and>
        </condition>
        <antcall target="unzip-windows-jre">
            <param name="unzip.windows.jre.src" value="${windows.jre.arch.zip}" />
            <param name="unzip.windows.jre.dest" value="${light.dir}" />
        </antcall>
        <!-- Include any additional files if provided. -->
        <copy todir="${light.dir}">
            <fileset
                    casesensitive="false"
                    dir="${inst.resrc}/windows/installer-windows.wxs_FILES"
                    erroronmissingdir="false"
                    includes="**" />
        </copy>

        <!--
            This update-location.properties file is the only of interest to the
            MSI i.e. it gets installed on the user machine.
        -->
        <copy
                file="${inst.resrc}/windows/update-location.properties"
                todir="${light.dir}"
                overwrite="true" />

        <property name="wix.home" value="C:\Program Files (x86)\WiX Toolset v4.0" />

        <!-- Execute heat.exe -->
        <exec
                executable="${user.home}\.nuget\packages\wixtoolset.heat\4.0.1\tools\net472\x64\heat.exe"
                dir="${light.dir}"
                failonerror="true">
            <arg value="dir" />
            <arg value="." />
            <arg value="-nologo" />
            <arg value="-ag" />
            <arg value="-cg" />
            <arg value="ComponentGroup_HeatExe" />
            <arg value="-out" />
            <arg value="${windows.app.dir}\tmp\heat.wxs" />
            <arg value="-sfrag" />
            <arg value="-suid" />
            <!--
                Suppress SelfReg because we do not have files that need it and
                we do not want the private Java Runtime Environment to end up
                registering such files.
            -->
            <arg value="-scom" />
            <arg value="-sreg" />
            <arg value="-svb6" />
            <arg value="-var" />
            <arg value="var.SourceDir" />
        </exec>

        <xslt
                in="${windows.app.dir}/tmp/heat.wxs"
                out="${windows.app.dir}/tmp/component-defines.wxi"
                style="${inst.resrc}/windows/heat-component-defines.xsl" />
        <xslt
                in="${windows.app.dir}/tmp/heat.wxs"
                out="${windows.app.dir}/tmp/component-refs.wxi"
                style="${inst.resrc}/windows/heat-component-refs.xsl" />

        <condition property="windows.is.64" value="yes" else="no">
            <equals arg1="${windows.arch}" arg2="64" />
        </condition>

        <path id="files-to-sign">
            <fileset dir="${light.dir}/native">
                <include name="**/*.dll"/>
                <include name="**/*.exe"/>
            </fileset>
            <file file="${light.dir}/${wix.app.launcher.name}.exe"/>
            <fileset dir="${light.dir}/ui">
                <include name="*.exe"/>
            </fileset>
        </path>

        <antcall target="wix-sign-file">
            <reference refid="files-to-sign" torefid="files.to.sign"/>
        </antcall>

        <!-- prepare properties for executing candle.exe -->
        <condition property="candle.var.Platform" value="x64" else="x86">
            <equals arg1="${windows.arch}" arg2="64" />
        </condition>
        <condition
                property="candle.arg.var.JRESetup"
                value="JRESetup=${windows.jre.arch.file}"
                else="NoJRESetup=true">
            <and>
                <isset property="windows.jre.arch.file" />
                <not>
                    <equals arg1="${windows.jre.arch.file}" arg2="" />
                </not>
                <not>
                    <isset property="windows.jre.arch.zip.isset" />
                </not>
            </and>
        </condition>

        <!-- should we create a separate msi target -->
        <condition property="msi.var.store" value="true" else="false">
            <equals arg1="${wix.store.msi}" arg2="true" />
        </condition>
        <antcall target="build-installation-wix-msi">
            <param name="msi.var.compress" value="high"/>
        </antcall>
        <move
                failonerror="false"
                file="${windows.app.dir}/tmp/setup.msi"
                preservelastmodified="true"
                tofile="${windows.app.dir}\${windows.msi.package.name}" />

        <!-- now build msi needed for the exe distribution without compression -->
        <antcall target="build-installation-wix-msi">
            <param name="msi.var.compress" value="none"/>
            <param name="wix.store.msi" value="true"/>
        </antcall>

        <!-- Bootstrap the MSI into an EXE. -->
        <exec
                dir="${windows.app.dir}/tmp"
                executable="${inst.resrc}/windows/xz.exe"
                failonerror="true">
            <arg value="-zk0v" />
            <arg value="setup.msi" />
        </exec>
        <exec
                dir="${src}/native/windows/setup"
                executable="make.exe"
                failonerror="true">
            <env key="PATH" path="${mingw.home}/bin;${env.PATH}" />
            <arg value="MINGW_HOME=${mingw.home}" />
            <arg value="TARGET_DIR=${windows.app.dir}/tmp" />
            <arg value="PRODUCTBUILDVERSION=${sip-communicator.version}" />
            <arg value="PRODUCTNAME=${application.name.ascii}" />
        </exec>

        <path id="installer-to-sign">
            <file file="${windows.app.dir}\tmp\setup.exe"/>
        </path>
        <antcall target="wix-sign-file">
            <reference refid="installer-to-sign" torefid="files.to.sign"/>
        </antcall>

        <move
                file="${windows.app.dir}/tmp/setup.exe"
                preservelastmodified="true"
                tofile="${windows.app.dir}\${windows.package.name}" />

        <!-- before deleting try building the deltas -->
        <antcall target="build-wix-delta-updates"/>

        <delete dir="${light.dir}" />
        <!-- tmp folder can cause problems uploading gitlab artifacts and is no longer needed -->
        <delete dir="${windows.app.dir}/tmp" />
    </target>

    <target name="build-installation-wix-msi" if="${wix.store.msi}">

        <!-- if application publisher is not set use application name -->
        <condition property="application.publisher"
                   value="${application.name.ascii}">
            <not>
                <isset property="application.publisher" />
            </not>
        </condition>

        <runtarget target="wix-template-replace" />

        <if><not><available file="${windows.app.dir}\tmp\${wix.locale.default.culture}.wxl" /></not>
        <then>
          <echo message="Creating wxl file" />
          <exec executable="sed" output="${windows.app.dir}\tmp\${wix.locale.default.culture}.wxl" logError="true" failonerror="true">
             <arg value="s/Language=\&quot;[0-9]\+\&quot;//g;s/@@PRODUCT_NAME_ASCII@@/${application.name.ascii}/g;s/@@PRODUCT_NAME_SHORT@@/${application.name}/g;s/@@PRODUCT_NAME_TITLECASE@@/${application.name}/g;s/@@TAGLINE@@/Unified Communications Client/g;s/@@WEB_PAGE@@/http:\/\/www.metaswitch.com/g;s/@@COMPANY_NAME@@/${application.publisher}/g;s/@@COMPANY_NAME_LEGAL@@/${application.publisher}/g"/>
             <arg value="${windows.app.dir}\tmp\${wix.locale.default.culture}.wxl.template"/>
          </exec>
        </then>
        </if>

        <if><not><available file="${windows.app.dir}\tmp\installer-windows.wxs" /></not>
        <then>
          <echo message="Creating installer-windows.wxs file" />
          <exec executable="sed" output="${windows.app.dir}\tmp\installer-windows.wxs" logError="true" failonerror="true">
             <arg value="s/@@PRODUCT_NAME_ASCII@@/${application.name.ascii}/g;s/@@OLD_PRODUCT_NAME_ASCII@@/${application.oldname.ascii}/g;s/@@PRODUCT_NAME_SHORT@@/${application.name}/g;s/@@PRODUCT_NAME_TITLECASE@@/${application.name}/g;s/@@TAGLINE@@/Unified Communications Client/g;s/@@WEB_PAGE@@/http:\/\/www.metaswitch.com/g;s/@@COMPANY_NAME@@/${application.publisher}/g;s/@@COMPANY_NAME_LEGAL@@/${application.publisher}/g"/>
             <arg value="${windows.app.dir}\tmp\installer-windows.wxs.template"/>
          </exec>
        </then>
        </if>

        <if><not><available file="${windows.app.dir}\tmp\SCRegistrySpec.wxi" /></not>
        <then>
          <echo message="Creating SCRegistrySpec.wxi file" />
          <exec executable="sed" output="${windows.app.dir}\tmp\SCRegistrySpec.wxi" logError="true" failonerror="true">
             <arg value="s/@@PRODUCT_NAME_ASCII@@/${application.name.ascii}/g;s/@@PRODUCT_NAME_SHORT@@/${application.name}/g;s/@@PRODUCT_NAME_TITLECASE@@/${application.name}/g;s/@@TAGLINE@@/Unified Communications Client/g;s/@@WEB_PAGE@@/http:\/\/www.metaswitch.com/g;s/@@COMPANY_NAME@@/${application.publisher}/g;s/@@COMPANY_NAME_LEGAL@@/${application.publisher}/g"/>
             <arg value="${windows.app.dir}\tmp\SCRegistrySpec.wxi.template"/>
          </exec>
        </then>
        </if>

        <echo message="Checking whether to build default locale:" />
        <echo message="  wix.locale.default.culture: ${wix.locale.default.culture}" />
        <echo message="  wix.locale.default.codepage: ${wix.locale.default.codepage}" />
        <echo message="  wix.locale.default.id: ${wix.locale.default.id}" />

        <!-- For pre-built resource packs, copy across the wxl and wxs files, making sure to replace properties where
            appropriate -->
        <if><not><available file="${windows.app.dir}\tmp\${wix.locale.default.culture}.wxl" /></not>
        <then>
          <echo message="Creating wxl file" />
          <exec executable="sed" output="${windows.app.dir}\tmp\${wix.locale.default.culture}.wxl" logError="true" failonerror="true">
             <arg value="s/Language=\&quot;[0-9]\+\&quot;//g;s/@@PRODUCT_NAME_SHORT@@/${application.name}/g;s/@@PRODUCT_NAME_TITLECASE@@/${application.name}/g;s/@@TAGLINE@@/Unified Communications Client/g;s/@@WEB_PAGE@@/http:\/\/www.metaswitch.com/g;s/@@COMPANY_NAME@@/${application.publisher}/g;s/@@COMPANY_NAME_LEGAL@@/${application.publisher}/g"/>
             <arg value="${windows.app.dir}\tmp\${wix.locale.default.culture}.wxl.template"/>
          </exec>
        </then>
        </if>

        <echo message="Checking whether to build default locale:" />
        <echo message="  wix.locale.default.culture: ${wix.locale.default.culture}" />
        <echo message="  wix.locale.default.codepage: ${wix.locale.default.codepage}" />
        <echo message="  wix.locale.default.id: ${wix.locale.default.id}" />

        <!-- Finish the preparation for the execution of wix tool -->
        <copy todir="${light.dir}" overwrite="true">
            <fileset dir="${inst.resrc}/doc">
                <include name="License.rtf" />
            </fileset>
            <fileset dir="${inst.resrc}/windows">
                <include name="wix-*.jpg" />
            </fileset>
        </copy>

        <!-- Execute wix.exe -->
        <exec
                executable="wix.exe"
                dir="${light.dir}"
                failonerror="true">
            <arg value="build" />
            <arg value="-arch" />
            <arg value="${candle.var.Platform}" />
            <arg value="-cc"/>
            <arg value="${light.dir}/cabcache"/>
            <arg value="${wix.light.additional.arg}" />
            <arg value="-ext" />
            <arg value="WixToolset.UI.wixext" />
            <arg value="-ext" />
            <arg value="WixToolset.Util.wixext" />
            <arg value="-d" />
            <arg value="codepage=${wix.locale.default.codepage}" />
            <arg value="-d" />
            <arg value="Platform=${candle.var.Platform}" />
            <arg value="-d" />
            <arg value="SourceDir=${windows.app.dir}\tmp\light" />
            <arg value="-d" />
            <arg value="${candle.arg.var.JRESetup}" />
            <arg value="-culture" />
            <arg value="${wix.locale.default.culture}" />
            <arg value="-loc" />
            <arg value="${windows.app.dir}\tmp\${wix.locale.default.culture}.wxl" />
            <arg value="-out" />
            <arg value="${windows.app.dir}\tmp\setup.msi" />
            <arg value="${windows.app.dir}\tmp\installer-windows.wxs" />
        </exec>

        <!-- Write locale id to file so we can verify we built the correct transforms later -->
        <echo file="${windows.app.dir}\tmp\built-locales.txt" message="${wix.locale.default.id}${line.separator}" />

        <!-- Create transform files for the supported setup locales.

             Supported locales for our version of Wix are documented here:
             https://wixtoolset.org//documentation/manual/v3/wixui/wixui_localization.html

             If the exact locale isn't supported, the closest available will be
             used (e.g users with Windows language set to fr-ca will use the fr-fr
             installer).  For languages that aren't supported at all (e.g. Indonesian),
             the installer will fall back to the default specified in ant-build-config.properties,
             (which is en-us unless overridden in a tailored branding). For all languages supported
             by the client (i.e. that have a resources_<locale>.properties.template file in
             jitsi/resources/languages), if their exact locale is not supported by Wix so
             cannot be added here, please ensure the locale is specified below in the comment
             corresponding to the Wix locale that we expect them to use.
        -->
        <antcall target="build-installation-wix-locale">
            <param name="locale.name" value="bg-bg"/>
            <param name="locale.codepage" value="1251"/>
            <param name="locale.id" value="1026"/>
        </antcall>
        <!-- Used for de-de and de-at locales -->
        <antcall target="build-installation-wix-locale">
            <param name="locale.name" value="de-de"/>
            <param name="locale.codepage" value="1252"/>
            <param name="locale.id" value="1031"/>
        </antcall>
        <!-- Note this doesn't match the el-cy locale, which uses the value 4096 (as do many other locales)-->
        <antcall target="build-installation-wix-locale">
            <param name="locale.name" value="el-gr"/>
            <param name="locale.codepage" value="1253"/>
            <param name="locale.id" value="1032"/>
        </antcall>
        <!-- Used for en-us, en-gb and in-id locales -->
        <antcall target="build-installation-wix-locale">
            <param name="locale.name" value="en-us"/>
            <param name="locale.codepage" value="1252"/>
            <param name="locale.id" value="1033"/>
        </antcall>
        <!-- Used for es-es and es-la locales -->
        <antcall target="build-installation-wix-locale">
            <param name="locale.name" value="es-es"/>
            <param name="locale.codepage" value="1252"/>
            <param name="locale.id" value="1034"/>
        </antcall>
        <!-- Used for fr-fr and fr-ca locales -->
        <antcall target="build-installation-wix-locale">
            <param name="locale.name" value="fr-fr"/>
            <param name="locale.codepage" value="1252"/>
            <param name="locale.id" value="1036"/>
        </antcall>
        <antcall target="build-installation-wix-locale">
            <param name="locale.name" value="hr-hr"/>
            <param name="locale.codepage" value="1250"/>
            <param name="locale.id" value="1050"/>
        </antcall>
        <antcall target="build-installation-wix-locale">
            <param name="locale.name" value="it-it"/>
            <param name="locale.codepage" value="1252"/>
            <param name="locale.id" value="1040"/>
        </antcall>
        <antcall target="build-installation-wix-locale">
            <param name="locale.name" value="pl-pl"/>
            <param name="locale.codepage" value="1250"/>
            <param name="locale.id" value="1045"/>
        </antcall>
        <!-- Used for pt-ao and pt-br locales -->
        <antcall target="build-installation-wix-locale">
            <param name="locale.name" value="pt-pt"/>
            <param name="locale.codepage" value="1252"/>
            <param name="locale.id" value="2070"/>
        </antcall>
        <antcall target="build-installation-wix-locale">
            <param name="locale.name" value="sk-sk"/>
            <param name="locale.codepage" value="1250"/>
            <param name="locale.id" value="1051"/>
        </antcall>
        <antcall target="build-installation-wix-locale">
            <param name="locale.name" value="sl-si"/>
            <param name="locale.codepage" value="1250"/>
            <param name="locale.id" value="1060"/>
        </antcall>
            <antcall target="build-installation-wix-locale">
            <param name="locale.name" value="th-th"/>
            <param name="locale.codepage" value="874"/>
            <param name="locale.id" value="1054"/>
        </antcall>

        <antcall target="build-installation-wix-locale">
            <param name="locale.name" value="zh-tw"/>
            <param name="locale.codepage" value="950"/>
            <param name="locale.id" value="1028"/>
        </antcall>

        <echo message="Check installer locales match built wix cultures exactly."/>
        <!-- If we have specified a locale in wix.locale.list but not built the culture, the installer will crash.
             If we have built a culture but not added the locale to wix.locale.list, the installer will not display in that locale.
             This check aims to catch both these problems at build time. -->

        <!-- Write wix.locale.list to a file for easier comparison -->
        <for list="${wix.locale.list}" param="locale.id">
            <sequential>
                <echo file="${windows.app.dir}\tmp\wix-locales.txt" append="true">@{locale.id}${line.separator}</echo>
            </sequential>
        </for>
        <exec executable="python3.8.exe" outputproperty="wix.locales.without.cultures">
            <arg path="${ext}/scripts/calculate_set_xor.py"/>
            <arg value="${windows.app.dir}\tmp\wix-locales.txt" />
            <arg path="${windows.app.dir}\tmp\built-locales.txt" />
        </exec>
        <fail>
            <condition><not><equals arg1="${wix.locales.without.cultures}" arg2=""/></not></condition>
            Error: Mismatch between built installer cultures and supported installer locales for locale ID(s): ${wix.locales.without.cultures}
            Have you:
            - Called build-installation-wix-locale for every supported installer language?
            - Checked in an installer template file (.wxl.template) for every supported installer language?
            - (For dev brandings) Disabled all unwanted installer languages?
        </fail>

        <!-- Update the msi to set available languages -->
        <exec
                executable="cscript.exe"
                dir="${light.dir}"
                failonerror="true">
            <arg value="${inst.resrc}\windows\WiLangId.vbs" />
            <arg value="${windows.app.dir}\tmp\setup.msi" />
            <arg value="Package" />
            <arg value="${wix.locale.default.id},${wix.locale.list}" />
        </exec>

        <!-- Once all locales have been built and put in the msi, sign it -->
        <path id="msi-installer-to-sign">
            <file file="${windows.app.dir}\tmp\setup.msi"/>
        </path>
        <antcall target="wix-sign-file">
            <reference refid="msi-installer-to-sign" torefid="files.to.sign"/>
        </antcall>
    </target>

    <!-- Creates localized msi installers and the resulting
        transform files-->
    <target name="build-installation-wix-locale">

        <!-- Used to work out whether we should build a culture based on the
             properties being set -->
        <macrodef name="build-culture">
            <attribute name="culture"/>
            <attribute name="property"/>
            <element name="build-culture-task" implicit="yes"/>
            <sequential>
                <echo message="Checking whether to build locale" />
                <echo message="  culture = @{culture}" />
                <echo message="  @{property} = ${@{property}}" />
                <echo message="  wix.locale.build.all = ${wix.locale.build.all}" />
                <echo message="  wix.locale.default.culture = ${wix.locale.default.culture}" />
                <if>
                    <and>
                        <or>
                            <and>
                                <isset property="@{property}"/>
                                <equals arg1="${@{property}}" arg2="true"/>
                            </and>
                            <and>
                                <isset property="wix.locale.build.all"/>
                                <equals arg1="${wix.locale.build.all}" arg2="true"/>
                            </and>
                        </or>
                        <not>
                          <equals arg1="@{culture}" arg2="${wix.locale.default.culture}" />
                        </not>
                     </and>
                    <then>
                        <build-culture-task />
                    </then>
                </if>
            </sequential>
        </macrodef>

        <build-culture culture="${locale.name}"
                       property="wix.locale.build.${locale.name}">
            <echo message="Building culture with id: ${locale.id} codepage: ${locale.codepage} name: ${locale.name}" />
            <if><not><available file="${windows.app.dir}\tmp\${locale.name}.wxl" /></not>
            <then>
              <echo message="Creating wxl file for ${locale.name}" />
              <exec executable="sed" output="${windows.app.dir}\tmp\${locale.name}.wxl" logError="true" failonerror="true">
                 <arg value="s/Language=\&quot;[0-9]\+\&quot;//g;s/@@@@PRODUCT_NAME_SHORT@@@@/${application.name}/g;s/@@@@PRODUCT_NAME_TITLECASE@@@@/${application.name}/g;s/@@@@TAGLINE@@@@/Unified Communications Client/g;s/@@@@WEB_PAGE@@@@/http:\/\/www.metaswitch.com/g;s/@@@@COMPANY_NAME@@@@/${application.publisher}/g;s/@@@@COMPANY_NAME_LEGAL@@@@/${application.publisher}/g"/>
                 <arg value="${windows.app.dir}\tmp\${locale.name}.wxl.template"/>
              </exec>
            </then>
            </if>

            <!-- Execute wix.exe for locale.name -->
            <exec
                    executable="wix.exe"
                    dir="${light.dir}"
                    failonerror="true">
                <arg value="build" />
                <arg value="-arch" />
                <arg value="${candle.var.Platform}" />
                <arg value="-cc"/>
                <arg value="${light.dir}/cabcache"/>
                <arg value="${wix.light.additional.arg}" />
                <arg value="-ext" />
                <arg value="WixToolset.UI.wixext" />
                <arg value="-ext" />
                <arg value="WixToolset.Util.wixext" />
                <arg value="-d" />
                <arg value="codepage=${locale.codepage}" />
                <arg value="-d" />
                <arg value="Platform=${candle.var.Platform}" />
                <arg value="-d" />
                <arg value="SourceDir=${windows.app.dir}\tmp\light" />
                <arg value="-d" />
                <arg value="${candle.arg.var.JRESetup}" />
                <arg value="-culture" />
                <arg value="${locale.name}" />
                <arg value="-loc" />
                <arg value="${windows.app.dir}\tmp\${locale.name}.wxl" />
                <arg value="-out" />
                <arg value="${windows.app.dir}\tmp\setup_${locale.name}.msi" />
                <arg value="${windows.app.dir}\tmp\installer-windows.wxs" />
            </exec>

            <exec
                    executable="wix.exe"
                    dir="${light.dir}"
                    failonerror="true">
                <arg value="msi" />
                <arg value="transform" />
                <arg value="-p" />
                <arg value="-t" />
                <arg value="language" />
                <arg value="${windows.app.dir}\tmp\setup.msi" />
                <arg value="${windows.app.dir}\tmp\setup_${locale.name}.msi" />
                <arg value="-out" />
                <arg value="${windows.app.dir}\tmp\${locale.name}.mst" />
            </exec>

            <!-- After we have created all transform files for all locales,
                        embed them into the setup msi one by one,
                        the last param is the LCID in order language to be
                        autoselected when msi is started
                        LCID info at:
                        http://msdn.microsoft.com/en-us/library/0h88fahh(v=vs.85).aspx

                        Note(2011-09-16 damencho):
                        every language added must be listed and in installer-windows.wxs
                        in the language attribute in Package and UpgradeVersion.
                        -->
            <exec
                    executable="cscript.exe"
                    dir="${light.dir}"
                    failonerror="true">
                <arg value="${inst.resrc}\windows\WiSubStg.vbs" />
                <arg value="${windows.app.dir}\tmp\setup.msi" />
                <arg value="${windows.app.dir}\tmp\${locale.name}.mst" />
                <arg value="${locale.id}" />
            </exec>

            <!-- Write locale id to file so we can verify we built the correct transforms later -->
            <echo file="${windows.app.dir}\tmp\built-locales.txt" message="${locale.id}${line.separator}" append="true"/>
        </build-culture>
    </target>

    <target name="build-wix-delta-updates"
            if="delta.history.location"
            depends="buildtools.init-ant-contrib" >

        <!-- Find all previous builds we have to build deltas for them -->
        <foreach param="build-location" target="-make-wix-delta"
                 inheritall="true" inheritrefs="true">
            <path>
                <dirset dir="${delta.history.location}">
                    <include name="*"/>
                </dirset>
            </path>
        </foreach>

        <!-- copy data for next delta builds-->
        <mkdir dir="${delta.history.location}/${build.label}/${windows.arch}"/>
        <copy file="${windows.app.dir}\tmp\setup.msi"
              todir="${delta.history.location}/${build.label}/${windows.arch}"/>

        <!-- now delete old one -->
        <antcall target="-delete-oldest-delta-data"/>
    </target>

    <target name="-make-wix-delta">

        <basename property="old.wix.build" file="${build-location}"/>

        <!-- we must skip building deltas for current build
            and if the source setup file is missing
        -->
        <condition property="process.delta">
            <and>
                <not>
                    <equals arg1="${old.wix.build}" arg2="${build.label}"/>
                </not>
                <available file="${build-location}\${windows.arch}\setup.msi"/>
            </and>
        </condition>

        <antcall target="-make-wix-delta-msi"/>
    </target>

    <target name="-make-wix-delta-msi" if="process.delta">
        <echo message="Creating msi delta for ${old.wix.build}-${build.label}"/>

        <!-- make the actual diff -->
        <exec executable="${inst.resrc}\windows\bsdiff.exe" failonerror="true">
            <arg value="${build-location}\${windows.arch}\setup.msi"/>
            <arg value="${windows.app.dir}\tmp\setup.msi"/>
            <arg value="${windows.app.dir}\tmp\setup.bspatch"/>
        </exec>

        <exec
                executable="cscript.exe"
                dir="${light.dir}"
                outputproperty="old.packagecode"
                failonerror="true">
            <arg value="//NoLogo" />
            <arg value="${inst.resrc}\windows\WiSumInf.vbs" />
            <arg value="${build-location}\${windows.arch}\setup.msi" />
        </exec>
        <echo message="Old package code is: ${old.packagecode}"/>
      <length
              file="${build-location}/${windows.arch}/setup.msi"
              property="old.packagesize" />
        <echo message="Old package size is: ${old.packagesize}"/>
        <exec
                dir="${src}/native/windows/setup"
                executable="make.exe"
                failonerror="true">
            <env key="PATH" path="${mingw.home}/bin;${env.PATH}" />
            <arg value="MINGW_HOME=${mingw.home}" />
            <arg value="TARGET_DIR=${windows.app.dir}/tmp" />
            <arg value="PACKAGECODE=${old.packagecode}" />
            <arg value="PACKAGESIZE=${old.packagesize}" />
            <arg value="PRODUCTBUILDVERSION=${sip-communicator.version}" />
        </exec>

        <path id="delta-installer-to-sign">
            <file file="${windows.app.dir}\tmp\setup.exe"/>
        </path>
        <antcall target="wix-sign-file">
            <reference refid="delta-installer-to-sign" torefid="files.to.sign"/>
        </antcall>

        <move
                file="${windows.app.dir}/tmp/setup.exe"
                preservelastmodified="true"
                tofile="${windows.app.dir}\${package.name}-${sip-communicator.version}-delta-${old.wix.build}-${windows.package.name.suffix}" />
    </target>

    <target name="wix-sign-file">
        <if>
            <and>
                <equals arg1="${env.SKIP_NOTARIZATION}" arg2="true"/>
                <not>
                    <equals arg1="${env.SIGN_WINDOWS}" arg2="true"/>
                </not>
            </and>
            <then>
                <echo message="Skipping Windows signing"/>
            </then>
            <else>
                <antcall target="signing.esrp-sign">
                    <reference refid="files.to.sign"/>
                </antcall>
            </else>
        </if>
    </target>
    <!-- - - - - - - - - - - BUILDING RELEASE PACKAGES - - - - - - - - - - - -->
    <!-- Internal target called by the "clean target" - removes the macosx-specific file -->
    <!-- we only execute if at least one (in this case the first) of the links we are
         deleting exist as otherwise we see a bunch of warnings on every compile. -->
    <available file="${macosx.resrc.dir}/logging.properties" property="macResourcesExist"/>
    <target name="clean-macosx" if="macResourcesExist">

        <delete failonerror="false" file="${macosx.resrc.dir}/jitsi-defaults.properties"/>
        <delete failonerror="false" file="${macosx.resrc.dir}/applicationinsights.json"/>
        <delete failonerror="false" file="${macosx.resrc.dir}/logging.properties"/>
        <delete failonerror="false" file="${macosx.resrc.dir}/felix.client.run.properties"/>
        <symlink action="delete" failonerror="false"
                 link="${${application.name.ascii}.app}/${application.name.ascii}.app/Contents/Resources/Java/libAEGetURLEventHandlerAgent.jnilib"/>

        <symlink action="delete" failonerror="false"
                 link="${macosx.app.dir}/${application.name.ascii}.app/Contents/Frameworks/Sparkle.framework/Headers"/>
        <symlink action="delete" failonerror="false"
                 link="${macosx.app.dir}/${application.name.ascii}.app/Contents/Frameworks/Sparkle.framework/Resources"/>
        <symlink action="delete" failonerror="false"
                 link="${macosx.app.dir}/${application.name.ascii}.app/Contents/Frameworks/Sparkle.framework/Sparkle"/>
        <symlink action="delete" failonerror="false"
                 link="${macosx.app.dir}/${application.name.ascii}.app/Contents/Frameworks/Sparkle.framework/Versions/Current"/>
        <symlink action="delete" failonerror="false"
                 link="${macosx.app.dir}/${application.name.ascii}.app/Contents/Frameworks/Sparkle.framework/Autoupdate"/>
        <symlink action="delete" failonerror="false"
                 link="${macosx.app.dir}/${application.name.ascii}.app/Contents/Frameworks/Sparkle.framework/Modules"/>
        <symlink action="delete" failonerror="false"
                 link="${macosx.app.dir}/${application.name.ascii}.app/Contents/Frameworks/Sparkle.framework/PrivateHeaders"/>
        <symlink action="delete" failonerror="false"
                 link="${macosx.app.dir}/${application.name.ascii}.app/Contents/Frameworks/Sparkle.framework/Updater.app"/>
        <symlink action="delete" failonerror="false"
                 link="${macosx.app.dir}/${application.name.ascii}.app/Contents/Frameworks/Sparkle.framework/XPCServices"/>
    </target>

    <target name="macosx" depends="version,load-properties,buildtools.init-ant-contrib,buildtools.init-appbundler,bundle-identifier"
            description="Create an .app package for MACOSX">

      <mkdir dir="${macosx.app.dir}"/>

        <!-- Prepare the logging.properties file for macosx -->
      <copy file="${inst.resrc}/logging.properties"
              tofile="${macosx.resrc.dir}/logging.properties"
              overwrite="true"/>
      <replace file="${macosx.resrc.dir}/logging.properties"
            token="java.util.logging.FileHandler.pattern = %h/.sip-communicator/log"
            value="java.util.logging.FileHandler.pattern = log"/>

        <!-- Prepare the felix.client.run.properties file for macosx -->
      <copy file="${lib}/felix.client.run.properties"
            tofile="${macosx.resrc.dir}/felix.client.run.properties"
            overwrite="true"/>

        <!-- Refer to custom-installer-build-targets.xml comment [1] -->
        <jar compress="false" destfile="${bundles.dest}/add-working-directory-to-classpath.jar">
            <manifest>
                <attribute name="Class-Path" value="." />
            </manifest>
        </jar>

        <!-- Prepare the jitsi-defaults.properties file for macosx -->
      <copy file="${lib}/jitsi-defaults.properties"
            tofile="${macosx.resrc.dir}/jitsi-defaults.properties"
            overwrite="true"
            failonerror="false"/>

        <!-- Prepare the applicationinsights.json file for macosx -->
      <copy file="${lib}/applicationinsights.json"
            tofile="${macosx.resrc.dir}/applicationinsights.json"
            overwrite="true"
            failonerror="false"/>

      <copy file="${lib}/jitsi-default-overrides.properties"
            tofile="${macosx.resrc.dir}/jitsi-default-overrides.properties"
            overwrite="true"
            failonerror="false"/>

      <!-- copy any resources that we'd like to be available to the installed client -->
      <copy todir="${macosx.resrc.dir}/resources" overwrite="true">
          <fileset dir="${sc.basedir}/resources/bundle"
                   includes="**/*">
          </fileset>
      </copy>

        <!-- Remove the reference to the update bundle -->
      <replace file="${macosx.resrc.dir}/felix.client.run.properties"
               token="reference:file:sc-bundles/updatewindows.jar"
               value=""/>
        <!-- colons can be escaped after some modifications -->
      <replace file="${macosx.resrc.dir}/felix.client.run.properties"
               token="reference\:file\:sc-bundles/updatewindows.jar"
               value=""/>
      <replaceregexp file="${macosx.resrc.dir}/felix.client.run.properties"
                match="^org.osgi.framework.storage=\$\{user.home\}/.sip-communicator/sip-communicator.bin"
                replace="org.osgi.framework.storage=$\{user.home\}/Library/Application Support/${application.name.ascii}/sip-communicator.bin"
                flags="m"/>

        <!-- Remove directory prefixes from the felix properties file -->
      <replace file="${macosx.resrc.dir}/felix.client.run.properties"
        token="sc-bundles/"
        value=""/>

      <replace file="${macosx.resrc.dir}/felix.client.run.properties"
        token="lib/bundle/"
        value=""/>

        <!-- We copy macosx-specific bundles from
           sc-bundles/os-specific/macosx to sc-bundles -->
      <copy todir="${bundles.dest}">
            <fileset dir="${bundles.dest.mac}">
                <include name="**/*.jar"/>
            </fileset>
      </copy>

        <!-- Delete the old .app if it exists -->
      <delete dir="${macosx.app.dir}/${application.name.ascii}.app"
              quiet="yes" failonerror="false"/>
        <!-- Delete the old tmp if it exists -->
      <delete dir="${macosx.app.dir}/tmp"
              quiet="yes" failonerror="false"/>
      <mkdir dir="${macosx.app.dir}/tmp"/>

        <!-- Sparkle needs the build number. If it is not
           available, we use the normal build label -->
      <condition property="sparkle.build"
                 value="${sparkle}"
                 else="${build.label}">
          <isset property="sparkle"/>
      </condition>

        <!-- removes any spaces from application name if any -->
      <propertyregex property="macosx.stub.filename"
            input="${application.name.ascii}"
            regexp=" "
            replace=""
            override="true"
            global="true"
            defaultValue="${application.name.ascii}"/>

        <!-- install_name_tool -change lib/native/mac/libjnwebrtc.dylib libjnwebrtc.dylib libjnwebrtcaec.dylib -->

      <fail unless="env.JRE_HOME" message="JRE_HOME is required but is not set."/>
      <basename property="macosx.jre.version" file="${env.JRE_HOME}/../.."/>

        <!-- sparkle.bundle.name is the name the .app should have. -->
        <condition property="sparkle.bundle.name" value="${application.name.ascii}" else="${su.bundle.name}">
            <equals arg1="${su.bundle.name}" arg2=""/>
        </condition>

        <!-- Attach the jacoco runtime agent to gather code coverage data, if configured to do so.
             If not, set a property that we don't actually use so that the app will still run (we
             can't nest an if statement inside bundleapp, so we have to set this to something as
             the app crashes if we set an empty option string.  Ick.).  -->
        <condition property="coverage.option.string"
                   value="-javaagent:$APP_ROOT/Contents/Java/org.jacoco.agent-runtime.jar=destfile=$APP_ROOT/Contents/coverage/${application.name.ascii}/installed.jacoco.exec"
                   else="-Dnet.java.sip.communicator.ENABLE_COVERAGE=false">
            <equals arg1="${env.ENABLE_COVERAGE}" arg2="true"/>
        </condition>
        <echo message="Coverage enabled? ${env.ENABLE_COVERAGE}. Setting javaagent string to: ${coverage.option.string}"/>

        <!-- Unzip the jdk into dist/branding-name -->
        <gunzip src="lib/microsoft-jdk-17.0.10-macos-x64.tar.gz"/>
        <untar src="lib/microsoft-jdk-17.0.10-macos-x64.tar" dest="."/>
        <!-- This creates the .app for MacOSX -->
        <bundleapp  outputdirectory="${macosx.app.dir}"
                    name="${application.name.ascii}"
                    displayname="${application.name.ascii}"
                    identifier="${bundle.identifier}"
                    icon="resources/images/logo/sc_logo_128x128.icns"
                    shortversion="${sparkle.build}"
                    version="${sparkle.build}"
                    signature="sipc"
                    executablename="${macosx.stub.filename}"
                    workingdirectory="$APP_ROOT/Contents/Java"
                    mainclassname="net.java.sip.communicator.launcher.SIPCommunicator" >

            <!-- Workaround since the icon parameter for bundleapp doesn't work -->
            <option value="-Xdock:icon=Contents/Resources/sc_logo_128x128.icns"/>
            <option value="-Xdock:name=${application.name.ascii}"/>
            <option value="-Dapp.name=${application.name.ascii}"/>
            <option value="-Dcom.apple.mrj.application.apple.menu.about.name=${application.name.ascii}"/>
            <option value="-Dapple.laf.useScreenMenuBar=true"/>
            <option value="-Dapple.awt.brushMetalRounded=true"/>
            <option value="-Dapple.awt.showGrowBox=true"/>
            <option value="-Dapple.awt.UIElement=true"/> <!-- Hide Java dock icon and menu bar by default -->
            <option value="-Dnet.java.sip.communicator.SC_HOME_DIR_NAME=${application.name.ascii}"/>
            <option value="-Dnet.java.sip.communicator.ELECTRON_APP_NAME=${application.name}"/>
            <option value="-Dnet.java.sip.communicator.SC_OLD_APP_NAME=${application.oldname.ascii}"/>
            <option value="-Dnet.java.sip.communicator.BUNDLE_IDENTIFIER=${bundle.identifier}"/>
            <option value="-XX:+UseG1GC" />
            <option value="-Xss576k"/>
            <option value="-Xmx256m"/>
            <option value="${coverage.option.string}"/>

            <!-- Remove limit on javacpp physicalBytes counter, due to issues where it miscounts on Mac. See https://github.com/bytedeco/javacpp/issues/516 and linked issues-->
            <option value="-Dorg.bytedeco.javacpp.maxPhysicalBytes=0"/>

            <!-- Restrict the Netty heap usage by limiting it to a single 4 MiB buffer (buffer size = 2^maxOrder * 8192) -->
            <option value="-Dio.netty.allocator.numHeapArenas=1"/>
            <option value="-Dio.netty.allocator.maxOrder=9"/>

            <!-- Tell felix to run sip-communicator -->
            <option value="-Dfelix.config.properties=file:$APP_ROOT/Contents/Java/felix.client.run.properties"/>
            <!-- Tell java.util.logging about our logging preferences -->
            <option value="-Djava.util.logging.config.file=$APP_ROOT/Contents/Java/logging.properties"/>

            <!-- Tell JNA not to try to unpack its native library files from its JAR file.  We provide them in the native library directory. -->
            <option value="-Djna.nounpack=true" />
            <!-- Tell JNA not to try to unpack its jnidispatch library files from its JAR file, but to load it
            from the native library directory instead. -->
            <option value="-Djna.nounpack=true" />
            <option value="-Djna.boot.library.path=$APP_ROOT/Contents/MacOS" />

            <!-- Run the Application Insights Agent -->
            <option value="-javaagent:$APP_ROOT/Contents/Java/applicationinsights-agent.jar" />

            <!-- Specify SUBundleName in Info.plist to support app name change over upgrade -->
            <plistentry key="SUBundleName" value="${sparkle.bundle.name}" />

            <!-- Change this to include the right runtime object... -->
            <runtime dir="${env.JRE_HOME}" />

            <classpath dir=".">
                <include name="lib/*.jar"/>
                <include name="lib/bundle/*.jar"/>
                <include name="${bundles.dest}/*.jar"/>
                <exclude name="${bundles.dest}/*-slick.jar"/>
                <exclude name="${bundles.dest}/sparkle.jar"/>
                <exclude name="${bundles.dest}/updatewindows.jar"/>
                <include name="resources/install/macosx/logging.properties"/>
                <include name="resources/install/macosx/felix.client.run.properties"/>
                <include name="resources/install/macosx/jitsi-defaults.properties"/>
                <include name="resources/install/macosx/applicationinsights.json"/>
                <include name="resources/install/macosx/jitsi-default-overrides.properties"/>
                <include name="resources/install/macosx/resources/**/*"/>
            </classpath>

            <librarypath dir=".">
                <include name="lib/native/mac/*.dylib"/>
                <include name="lib/native/mac/*.jnilib"/>
                <exclude name="lib/native/mac/libsparkle_init.dylib"/>
            </librarypath>
        </bundleapp>

        <!-- By default the bundleapp task puts a symlink for the libjli.dylib in
            Contents/MacOS. Code signing objects to this, as Mac OS X doesn't
            want a symlink as the main executable. -->
        <property name="macosx.app.jre.dir" value="${macosx.app.dir}/${application.name.ascii}.app/Contents/PlugIns/${macosx.jre.version}" />
        <delete file="${macosx.app.jre.dir}/Contents/MacOS/libjli.dylib" />

        <copy file="${env.JRE_HOME}/lib/libjli.dylib" tofile="${macosx.app.jre.dir}/Contents/MacOS/libjli.dylib" />

        <!-- Bundle in the jacoco runtime agent if we're configured to get coverage from the built client -->
        <if>
            <equals arg1="${env.ENABLE_COVERAGE}" arg2="true"/>
            <then>
                <echo message="ENABLE_COVERAGE is set to true so bundling in org.jacoco.agent-runtime.jar" />
                <copy file="${project.basedir}/buildtools/org.jacoco.agent-runtime.jar" todir="${macosx.app.dir}/${application.name.ascii}.app/Contents/Java" overwrite="true"/>
            </then>
            <else>
                <echo message="Not bundling in org.jacoco.agent-runtime.jar as ENABLE_COVERAGE is not set to true: ${env.ENABLE_COVERAGE}" />
            </else>
        </if>

        <property name="cfbundleurltypes.start" >
            <![CDATA[<key>CFBundleURLTypes</key>
          <array>
            <dict>
                <key>CFBundleURLName</key>
                    <string>sip URI</string>
                    <key>CFBundleURLSchemes</key>
                    <array>
                        <string>sip</string>
                    </array>
            </dict>
            <dict>
                <key>CFBundleURLName</key>
                    <string>callto URI</string>
                    <key>CFBundleURLSchemes</key>
                    <array>
                        <string>callto</string>
                    </array>
            </dict>
            <dict>
                <key>CFBundleURLName</key>
                    <string>tel URI</string>
                    <key>CFBundleURLSchemes</key>
                    <array>
                        <string>tel</string>
                    </array>
            </dict>
            <dict>
                <key>CFBundleURLName</key>
                    <string>xmpp URI</string>
                    <key>CFBundleURLSchemes</key>
                    <array>
                        <string>xmpp</string>
                    </array>
            </dict>]]>
        </property>

        <property name="cfbundleurltypes.end">
            <![CDATA[
          </array>
          <key>CFBundleName</key>]]>
        </property>

        <runtarget target="define-custom-cfbundleurltypes" />

        <!-- Create the URL types object by concatenating the variables together -->
        <property name="cfbundleURLTypes"
                  value="${cfbundleurltypes.start}${cfbundleurltypes.custom}${cfbundleurltypes.end}" />

        <!-- Add the url types in the Info.plist file -->
        <replace file="${macosx.app.dir}/${application.name.ascii}.app/Contents/Info.plist"
                 value="${cfbundleURLTypes}">
        <replacetoken><![CDATA[<key>CFBundleName</key>]]></replacetoken>
        </replace>

        <!-- Add property for high resolution displays -->
        <replace file="${macosx.app.dir}/${application.name.ascii}.app/Contents/Info.plist">
        <replacetoken><![CDATA[<key>CFBundleName</key>]]></replacetoken>
          <replacevalue><![CDATA[<key>NSHighResolutionCapable</key>
        <true/>
        <key>CFBundleName</key>]]></replacevalue>
        </replace>

        <!-- Add property for switching GPUs automatically if available -->
        <replace file="${macosx.app.dir}/${application.name.ascii}.app/Contents/Info.plist">
            <replacetoken><![CDATA[<key>CFBundleName</key>]]></replacetoken>
            <replacevalue><![CDATA[<key>NSSupportsAutomaticGraphicsSwitching</key>
        <true/>
        <key>CFBundleName</key>]]></replacevalue>
        </replace>

        <!-- Add property for localized bundle display names -->
        <replace file="${macosx.app.dir}/${application.name.ascii}.app/Contents/Info.plist">
        <replacetoken><![CDATA[<key>CFBundleName</key>]]></replacetoken>
          <replacevalue><![CDATA[<key>LSHasLocalizedDisplayName</key>
        <true/>
        <key>CFBundleName</key>]]></replacevalue>
        </replace>

        <!-- Delete the tmp if it exists -->
       <delete dir="${macosx.app.dir}/tmp"
              quiet="yes" failonerror="false"/>
    </target>

    <target name="add-headset-lib" depends="macosx" description="Move headset libraries to MacOS">
          <!-- Install the headset libs in the Java directory in the application package. -->
          <move file="${macosx.resrc.dir}/libjabra.dylib"
                tofile="${macosx.app.dir}/${application.name.ascii}.app/Contents/Java/libjabra.dylib"
                preservelastmodified="true"
                overwrite="true" filtering="yes">
          </move>
          <move file="${macosx.resrc.dir}/libyealinkusbsdk.dylib"
                tofile="${macosx.app.dir}/${application.name.ascii}.app/Contents/Java/libyealinkusbsdk.dylib"
                preservelastmodified="true"
                overwrite="true" filtering="yes">
          </move>
    </target>

    <!-- Create a MacOSX application package with Sparkle support.
         Executed only if the sparkle label property is set, i.e. if the
         package is built from CruiseControl -->
    <target name="macosx-sparkle" depends="macosx"
            if="sparkle"
            description="Create an .app package for MACOSX with Sparkle support">

        <!-- Add the sparkle bundle path in the felix.client.run.properties file -->
      <echo file="${macosx.app.dir}/${application.name.ascii}.app/Contents/Java/felix.client.run.properties"
            append="true">felix.auto.start.71= reference:file:sparkle.jar
      </echo>

        <!-- Add the Sparkle bundle and JNI to the application package -->
      <copy file="${bundles.dest}/sparkle.jar"
            todir="${macosx.app.dir}/${application.name.ascii}.app/Contents/Java"/>
      <copy file="lib/native/mac/libsparkle_init.dylib"
            todir="${macosx.app.dir}/${application.name.ascii}.app/Contents/MacOS"/>

        <!-- Add the Sparkle properties in the Info.plist file -->
      <replace file="${macosx.app.dir}/${application.name.ascii}.app/Contents/Info.plist">
        <replacetoken><![CDATA[<key>CFBundleName</key>]]></replacetoken>
        <replacevalue><![CDATA[<key>SUCheckAtStartup</key>
    <string>YES</string>
    <key>SUEnableAutomaticChecks</key>
    <string>YES</string>
    <key>SUScheduledCheckInterval</key>
    <string>86400</string>
    <key>SUPublicEDKey</key>
    <string>iWZ5qKeRSGktmrg1b5cbUODa46Kd9W6vCP21/VA3S64=</string>
    <key>SUFeedURL</key>
    <string>_DOWNLOAD_LINK_</string>
    <key>SUShowReleaseNotes</key>
    <string>NO</string>
    <key>CFBundleName</key>]]></replacevalue>
      </replace>

        <!-- Now replace the download link-->
      <replace file="${macosx.app.dir}/${application.name.ascii}.app/Contents/Info.plist">
        <replacefilter token="_DOWNLOAD_LINK_" value="${link.updates.macosx}"/>
      </replace>

        <!-- Add the permissions strings to the Info.plist file -->
        <replace file="${macosx.app.dir}/${application.name.ascii}.app/Contents/Info.plist">
            <replacetoken><![CDATA[<key>CFBundleName</key>]]></replacetoken>
            <replacevalue><![CDATA[
            <!-- These string values are ignored - the values are used from the localized InfoPlist.strings files -->
            <key>NSMicrophoneUsageDescription</key>
            <string>_MICROPHONE_USAGE_STRING_</string>
            <key>NSCameraUsageDescription</key>
            <string>_CAMERA_USAGE_STRING_</string>
            <key>NSContactsUsageDescription</key>
            <string>_CONTACTS_USAGE_STRING_</string>
            <key>NSDownloadsFolderUsageDescription</key>
            <string>_DOWNLOADS_USAGE_STRING_</string>
            <key>NSDesktopFolderUsageDescription</key>
            <string>_DESKTOP_USAGE_STRING_</string>
            <key>NSDocumentsFolderUsageDescription</key>
            <string>_DOCUMENTS_USAGE_STRING_</string>
            <key>NSNetworkVolumesUsageDescription</key>
            <string>_NETWORK_DRIVES_USAGE_STRING_</string>
            <key>NSLocationUsageDescription</key>
            <string>_LOCATION_USAGE_STRING_</string>
            <key>NSRemovableVolumesUsageDescription</key>
            <string>_REMOVABLE_DRIVES_USAGE_STRING_</string>
            <key>NSBluetoothAlwaysUsageDescription</key>
            <string>_BLUETOOTH_USAGE_STRING_</string>
            <key>CFBundleName</key>]]></replacevalue>
        </replace>

        <!-- Install the Sparkle Framework in the application package -->
      <mkdir dir="${macosx.app.dir}/${application.name.ascii}.app/Contents/Frameworks"/>
      <unzip src="${macosx.resrc.dir}/Sparkle.framework.zip"
            dest="${macosx.app.dir}/${application.name.ascii}.app/Contents/Frameworks"/>
        <!-- Ant unzip tasks does not preserve symlinks, so we recreate them -->
      <symlink link="${macosx.app.dir}/${application.name.ascii}.app/Contents/Frameworks/Sparkle.framework/Versions/Current"
            resource="./B"/>
      <symlink link="${macosx.app.dir}/${application.name.ascii}.app/Contents/Frameworks/Sparkle.framework/Autoupdate"
            resource="./Versions/Current/Autoupdate"/>
      <symlink link="${macosx.app.dir}/${application.name.ascii}.app/Contents/Frameworks/Sparkle.framework/Headers"
            resource="./Versions/Current/Headers"/>
      <symlink link="${macosx.app.dir}/${application.name.ascii}.app/Contents/Frameworks/Sparkle.framework/Modules"
            resource="./Versions/Current/Modules"/>
      <symlink link="${macosx.app.dir}/${application.name.ascii}.app/Contents/Frameworks/Sparkle.framework/PrivateHeaders"
            resource="./Versions/Current/PrivateHeaders"/>
      <symlink link="${macosx.app.dir}/${application.name.ascii}.app/Contents/Frameworks/Sparkle.framework/Resources"
            resource="./Versions/Current/Resources"/>
      <symlink link="${macosx.app.dir}/${application.name.ascii}.app/Contents/Frameworks/Sparkle.framework/Sparkle"
            resource="./Versions/Current/Sparkle"/>
      <symlink link="${macosx.app.dir}/${application.name.ascii}.app/Contents/Frameworks/Sparkle.framework/Updater.app"
            resource="./Versions/Current/Updater.app"/>
      <symlink link="${macosx.app.dir}/${application.name.ascii}.app/Contents/Frameworks/Sparkle.framework/XPCServices"
            resource="./Versions/Current/XPCServices"/>

        <!-- Restore the file permissions to the Sparkle relaunch tool -->
      <chmod file="${macosx.app.dir}/${application.name.ascii}.app/Contents/Frameworks/Sparkle.framework/Resources/relaunch"
               perm="ugo+rx"/>
      <chmod file="${macosx.app.dir}/${application.name.ascii}.app/Contents/Frameworks/Sparkle.framework/Versions/B/Sparkle"
               perm="ugo+rx"/>
      <chmod file="${macosx.app.dir}/${application.name.ascii}.app/Contents/Frameworks/Sparkle.framework/Versions/B/Autoupdate"
               perm="ugo+rx"/>
      <chmod file="${macosx.app.dir}/${application.name.ascii}.app/Contents/Frameworks/Sparkle.framework/Versions/B/Updater.app/Contents/MacOS/Updater"
               perm="ugo+rx"/>

        <!-- If the customer wants a none ASCII app name, we need to fix up the Info.plist file :( -->
            <if><available file="${macosx.resrc.dir}/fixAsciiInfoPlist.txt" />
            <then>
              <echo message="De-ASCIIifying Info.plist" />
                <exec executable="bash" logError="true" failonerror="true">
                  <arg value="-xe" />
                  <arg value="${macosx.resrc.dir}/fixAsciiInfoPlist.sh" />
                  <arg value="${macosx.resrc.dir}" />
                  <arg value="${macosx.app.dir}" />
                  <arg value="${application.name.ascii}" />
              </exec>
            </then>
            </if>
    </target>

    <!-- Creates empty folders in Contents/Resources for
          available languages, so macosx can switch languages -->
    <target name="dmg-create-language-folders"
            depends="buildtools.init-ant-contrib" >
        <foreach param="file.language.resource" target="dmg-language-folder"
                 inheritall="true" inheritrefs="true">
            <path>
                <fileset dir="${sc.basedir}/resources/languages">
                    <include name="resources_*.properties"/>
                </fileset>
                <fileset dir="${sc.basedir}/resources/sounds">
                    <include name="ring_*.wav"/>
                </fileset>
            </path>
        </foreach>
    </target>
    <target name="dmg-language-folder">
        <propertyregex property="jitsi.available.lang.resource"
                      input="${file.language.resource}"
                      regexp="(?:ring|resources)_(.*)\.(?:wav|properties)"
                      select="\1"
                      casesensitive="false"
                      defaultValue="en"/>
        <mkdir dir="${macosx.app.dir}/${application.name.ascii}.app/Contents/Resources/${jitsi.available.lang.resource}.lproj"/>

        <!-- Create InfoPlist.strings files in the Mac OS resources folders for each supported language -->
        <if><available file="${sc.basedir}/resources/languages/resources_${jitsi.available.lang.resource}.properties"/>
            <then>
                <echo message="Including InfoPlistPermissions.strings in ${jitsi.available.lang.resource}.lproj" />
                <!-- Combine optional branding strings (excluding permission strings) with permissions strings we always need (in separate append concat)-->
                <concat destfile="${macosx.app.dir}/${application.name.ascii}.app/Contents/Resources/${jitsi.available.lang.resource}.lproj/InfoPlist.strings" ignoreempty="false">
                    <fileset file="${sc.basedir}/resources/install/macosx/InfoPlist.strings"/>
                    <filterchain>
                        <linecontains negate="true">
                            <contains value="UsageDescription"/>
                        </linecontains>
                    </filterchain>
                </concat>
                <concat destfile="${macosx.app.dir}/${application.name.ascii}.app/Contents/Resources/${jitsi.available.lang.resource}.lproj/InfoPlist.strings" append="true">
                    <fileset file="${sc.basedir}/resources/install/macosx/InfoPlistPermissions.strings" />
                </concat>

                <!-- Permission strings -->
                <!-- Load the branding provided permission strings -->
                <if><available file="${sc.basedir}/resources/install/macosx/InfoPlist.strings"/>
                    <then>
                        <loadproperties srcFile="${sc.basedir}/resources/install/macosx/InfoPlist.strings" prefix="service.macospermissions.">
                            <filterchain>
                                <linecontains>
                                    <contains value="UsageDescription"/>
                                </linecontains>
                            </filterchain>
                        </loadproperties>
                    </then>
                </if>

                <!-- Load the language specific permission strings -->
                <loadproperties srcFile="${sc.basedir}/resources/languages/resources_${jitsi.available.lang.resource}.properties">
                    <filterchain>
                        <linecontains>
                            <contains value="service.macospermissions"/>
                        </linecontains>
                    </filterchain>
                </loadproperties>

                <!-- Fill any remaining with default values -->
                <loadproperties srcFile="${sc.basedir}/resources/languages/resources.properties">
                    <filterchain>
                        <linecontains>
                            <contains value="service.macospermissions"/>
                        </linecontains>
                    </filterchain>
                </loadproperties>

                <!-- Replace key with provided permissions string, preferring the branding provided string over the language-specific string -->
                <antcall target="permissions-string-replace">
                    <param name="branding.key" value="service.macospermissions.NSMicrophoneUsageDescription"/>
                    <param name="branding.string" value="${service.macospermissions.NSMicrophoneUsageDescription}"/>
                    <param name="permissions.key" value="_MICROPHONE_USAGE_STRING_"/>
                    <param name="permissions.string" value="${service.macospermissions.MAC_MICROPHONE_USAGE_STRING}"/>
                </antcall>
                <antcall target="permissions-string-replace">
                    <param name="branding.key" value="service.macospermissions.NSCameraUsageDescription"/>
                    <param name="branding.string" value="${service.macospermissions.NSCameraUsageDescription}"/>
                    <param name="permissions.key" value="_CAMERA_USAGE_STRING_"/>
                    <param name="permissions.string" value="${service.macospermissions.MAC_CAMERA_USAGE_STRING}"/>
                </antcall>
                <antcall target="permissions-string-replace">
                    <param name="branding.key" value="service.macospermissions.NSContactsUsageDescription"/>
                    <param name="branding.string" value="${service.macospermissions.NSContactsUsageDescription}"/>
                    <param name="permissions.key" value="_CONTACTS_USAGE_STRING_"/>
                    <param name="permissions.string" value="${service.macospermissions.MAC_CONTACTS_USAGE_STRING}"/>
                </antcall>
                <antcall target="permissions-string-replace">
                    <param name="branding.key" value="service.macospermissions.NSDownloadsFolderUsageDescription"/>
                    <param name="branding.string" value="${service.macospermissions.NSDownloadsFolderUsageDescription}"/>
                    <param name="permissions.key" value="_DOWNLOADS_USAGE_STRING_"/>
                    <param name="permissions.string" value="${service.macospermissions.MAC_DOWNLOADS_USAGE_STRING}"/>
                </antcall>
                <antcall target="permissions-string-replace">
                    <param name="branding.key" value="service.macospermissions.NSDesktopFolderUsageDescription"/>
                    <param name="branding.string" value="${service.macospermissions.NSDesktopFolderUsageDescription}"/>
                    <param name="permissions.key" value="_DESKTOP_USAGE_STRING_"/>
                    <param name="permissions.string" value="${service.macospermissions.MAC_DESKTOP_USAGE_STRING}"/>
                </antcall>
                <antcall target="permissions-string-replace">
                    <param name="branding.key" value="service.macospermissions.NSDocumentsFolderUsageDescription"/>
                    <param name="branding.string" value="${service.macospermissions.NSDocumentsFolderUsageDescription}"/>
                    <param name="permissions.key" value="_DOCUMENTS_USAGE_STRING_"/>
                    <param name="permissions.string" value="${service.macospermissions.MAC_DOCUMENTS_USAGE_STRING}"/>
                </antcall>
                <antcall target="permissions-string-replace">
                    <param name="branding.key" value="service.macospermissions.NSNetworkVolumesUsageDescription"/>
                    <param name="branding.string" value="${service.macospermissions.NSNetworkVolumesUsageDescription}"/>
                    <param name="permissions.key" value="_NETWORK_DRIVES_USAGE_STRING_"/>
                    <param name="permissions.string" value="${service.macospermissions.MAC_NETWORK_DRIVES_USAGE_STRING}"/>
                </antcall>
                <antcall target="permissions-string-replace">
                    <param name="branding.key" value="service.macospermissions.NSRemovableVolumesUsageDescription"/>
                    <param name="branding.string" value="${service.macospermissions.NSRemovableVolumesUsageDescription}"/>
                    <param name="permissions.key" value="_REMOVABLE_DRIVES_USAGE_STRING_"/>
                    <param name="permissions.string" value="${service.macospermissions.MAC_REMOVABLE_DRIVES_USAGE_STRING}"/>
                </antcall>
                <antcall target="permissions-string-replace">
                    <param name="branding.key" value="service.macospermissions.NSLocationUsageDescription"/>
                    <param name="branding.string" value="${service.macospermissions.NSLocationUsageDescription}"/>
                    <param name="permissions.key" value="_LOCATION_USAGE_STRING_"/>
                    <param name="permissions.string" value="${service.macospermissions.MAC_LOCATION_USAGE_STRING}"/>
                </antcall>
                <antcall target="permissions-string-replace">
                    <param name="branding.key" value="service.macospermissions.NSBluetoothAlwaysUsageDescription"/>
                    <param name="branding.string" value="${service.macospermissions.NSBluetoothAlwaysUsageDescription}"/>
                    <param name="permissions.key" value="_BLUETOOTH_USAGE_STRING_"/>
                    <param name="permissions.string" value="${service.macospermissions.MAC_BLUETOOTH_USAGE_STRING}"/>
                </antcall>
            </then>
        </if>
    </target>
    <target name="permissions-string-replace">
        <if><isset property="${branding.key}"/>
            <then>
                <replace file="${macosx.app.dir}/${application.name.ascii}.app/Contents/Resources/${jitsi.available.lang.resource}.lproj/InfoPlist.strings">
                    <!-- branding.string already contains the '"' and ';' so replace these characters too -->
                    <replacefilter token='"${permissions.key}";' value="${branding.string}"/>
                </replace>
            </then>
            <else>
                <replace file="${macosx.app.dir}/${application.name.ascii}.app/Contents/Resources/${jitsi.available.lang.resource}.lproj/InfoPlist.strings">
                    <replacefilter token="${permissions.key}" value="${permissions.string}"/>
                </replace>
            </else>
        </if>
    </target>

    <!-- Create the DMG - This only works on MacOSX (need hdiutil) -->
    <target name="dmg" depends="macosx-sparkle,add-headset-lib,mac-electron"
            if="is.running.macos"
            description="Create a .dmg package for MACOSX (only works on MACOSX)">

      <foreach param="plugin-location" target="-macosx-installer-plugin" >
        <path refid="included.plugins" />
      </foreach>

      <propertyregex property="package.name.despaced" input="${package.name}"
                     regexp="\s" replace="" global="true"/>

      <property name="macosx.dmg.name"
                value="${package.name.despaced}-${sip-communicator.version}.dmg"/>
      <property name="macosx.dmg.tmpname"
                value="${package.name.despaced}-tmp.dmg"/>
      <delete file="${macosx.app.dir}/${macosx.dmg.name}"
              quiet="yes" failonerror="false"/>

        <!-- Creates empty folders in Contents/Resources for
      available languages, so macosx can switch languages -->
      <antcall target="dmg-create-language-folders" />

        <!-- sign before creating the image, so the signed app goes into it -->
      <retry retrycount="2" retrydelay="10000">
        <antcall target="macosx-sign-app"/>
      </retry>

        <!-- Unmount any Disk Images before continuing or the build will fail -->
      <exec executable="/bin/bash" os="Mac OS X" failonerror="false">
        <arg value="${sc.basedir}/resources/install/unmountAll.sh"/>
      </exec>

        <!-- Create a temporary Disk Image -->
      <exec executable="/usr/bin/hdiutil" os="Mac OS X" failonerror="true">
        <arg value="create"/>
        <arg value="${macosx.app.dir}/${macosx.dmg.tmpname}"/>
        <arg value="-srcfolder"/>
        <arg value="${macosx.app.dir}/${application.name.ascii}.app"/>
        <arg value="-volname"/>
        <arg value="${application.name.ascii}"/>
        <arg value="-ov"/>
        <arg value="-format"/>
        <arg value="UDRW"/>
        <arg value="-verbose"/>
      </exec>

        <!-- Attach the temporary image -->
      <exec executable="/usr/bin/hdiutil" os="Mac OS X" failonerror="true">
        <arg value="attach"/>
        <arg value="-readwrite"/>
        <arg value="-noverify"/>
        <arg value="-noautoopen"/>
        <arg value="${macosx.app.dir}/${macosx.dmg.tmpname}"/>
        <arg value="-mountroot"/>
        <arg value="${release}"/>
      </exec>

        <!-- Copy the background and icon and deletes .DS_STORE file -->
      <mkdir dir="${release}/${application.name.ascii}/.background"/>
      <copy file="${macosx.resrc.dir}/dmg-background.png"
              tofile="${release}/${application.name.ascii}/.background/background.png"
              overwrite="true"/>
      <copy file="${macosx.resrc.dir}/dmg-VolumeIcon.icns"
              tofile="${release}/${application.name.ascii}/.VolumeIcon.icns"
              overwrite="true"/>
      <delete file="${release}/${application.name.ascii}/.DS_Store"
                quiet="yes" failonerror="false"/>
      <exec executable="SetFile" os="Mac OS X">
        <arg value="-a"/>
        <arg value="C"/>
        <arg value="${release}/${application.name.ascii}"/>
      </exec>

        <!-- Add a symbolic link to the Applications directory -->
      <symlink link="${release}/${application.name.ascii}/Applications" resource="/Applications"/>

        <!-- Use AppleScript to set the visual styles -->
      <exec executable="osascript" os="Mac OS X" failonerror="true">
        <arg value="${brand-location}/resources/install/dmgLayout.txt"/>
        <arg value="${application.name.ascii}"/>
      </exec>

        <!-- Sync memory and disk -->
      <exec executable="sync" os="Mac OS X" failonerror="true">
      </exec>

        <!-- Compress it to a new read only image -->
      <exec executable="/usr/bin/hdiutil" os="Mac OS X" failonerror="true">
        <arg value="convert"/>
        <arg value="${macosx.app.dir}/${macosx.dmg.tmpname}"/>
        <arg value="-format"/>
        <arg value="UDZO"/>
        <arg value="-o"/>
        <arg value="${macosx.app.dir}/${macosx.dmg.name}"/>
      </exec>

        <!-- Delete the temporary image -->
      <delete file="${macosx.app.dir}/${macosx.dmg.tmpname}"
              quiet="yes" failonerror="false"/>

        <!-- Unlock the keychain with 20 minute timeout -->
      <antcall target="macosx-unlock-keychain"/>

        <!-- Sign the .dmg -->
        <echo message="Codesigning .dmg disk image"/>
        <exec executable="/usr/bin/codesign" os="Mac OS X" failonerror="true">
            <arg value="-f"/>
            <arg value="-s"/>
            <arg value="${macosx.sign.certid}"/>
            <arg value="--timestamp"/>
            <arg value="-i"/>
            <arg value="${bundle.identifier}"/>
            <arg value="${macosx.app.dir}/${macosx.dmg.name}"/>
        </exec>

        <!-- Lock the keychain again -->
      <antcall target="macosx-lock-keychain"/>

        <!-- Notarize the app if required -->
      <if>
        <equals arg1="${env.SKIP_NOTARIZATION}" arg2="true"/>
        <then>
            <echo message="Skipping notarization"/>
        </then>
        <else>
            <runtarget target="macosx-notarize-app"/>

                <!-- Verify that the package has been notarised correctly -->
            <echo message="Assessing .app after notarisation"/>
                <!-- Attach disk image -->
            <exec executable="/usr/bin/hdiutil" failonerror="true">
                <arg value="attach"/>
                <arg value="${macosx.app.dir}/${macosx.dmg.name}"/>
                <arg value="-mountroot"/>
                <arg value="${macosx.app.dir}/Test"/>
            </exec>
                <!-- Check the app passes Gatekeeper execution checks -->
            <exec executable="/usr/sbin/spctl" resultproperty="return-code" errorproperty="error-message">
                <arg value="-a"/>
                <arg value="-t"/>
                <arg value="exec"/>
                <arg value="-vvv"/>
                <arg value="${macosx.app.dir}/Test/${application.name.ascii}/${application.name.ascii}.app"/>
            </exec>
                <!-- Detach disk image -->
            <exec executable="/usr/bin/hdiutil" failonerror="true">
                <arg value="detach"/>
                <arg value="${macosx.app.dir}/Test/${application.name.ascii}"/>
            </exec>
                <!-- Remove temporary directory -->
            <delete dir="${macosx.app.dir}/Test"
                    quiet="yes" failonerror="false"/>
                <!-- Fail the build on unsuccessful spctl check -->
            <fail>
                <condition><not><equals arg1="${return-code}" arg2="0"/></not></condition>
                Gatekeeper check failed. Error: ${error-message}
            </fail>
        </else>
      </if>

        <!-- creates the sparkle xmls -->
      <antcallback target="macosx-sparkle-files" return="sparkle.appcast.file"/>
      <antcall target="macosx-sparkle-delta-updates">
          <param name="sparkle.appcast.file" value="${sparkle.appcast.file}"/>
      </antcall>
      <antcall target="macosx-sparkle-files-finish">
          <param name="sparkle.appcast.file" value="${sparkle.appcast.file}"/>
      </antcall>

        <!-- remove folder we are done -->
      <delete dir="${macosx.app.dir}/${application.name.ascii}.app"
              quiet="yes" failonerror="false"/>
    </target>

    <!--
        If there is a property enabling the keychain name
        we can sign.
     -->
    <target name="macosx-sign-app" if="macosx.sign.keychain" unless="env.LOCAL_BUILD">
        <echo message="Signing application!"/>

        <!-- Unlock the keychain with 20 minute timeout -->
        <antcall target="macosx-unlock-keychain"/>

        <echo message="Codesigning all .dylib files"/>
        <apply executable="/usr/bin/codesign" parallel="false" os="Mac OS X" failonerror="true">
            <arg value="-v"/>
            <arg value="-f"/>
            <arg value="--options"/>
            <arg value="runtime"/>
            <arg value="--entitlements"/>
            <arg value="${sc.basedir}/resources/install/macosx/entitlements.xml"/>
            <arg value="-s"/>
            <arg value="${macosx.sign.certid}"/>
            <srcfile/>
            <fileset dir="${macosx.app.dir}/${application.name.ascii}.app/Contents/Java" includes="*.dylib"/>
        </apply>

        <!--
            This signs the following three libraries:
                - libnetty_resolver_dns_native_macos_x86_64.jnilib
                - libnetty_transport_native_kqueue_x86_64.jnilib
                - libjnidispatch.jnilib
            Since signing the libraries messes up the sha-digest, signatures and manifests need to be purged
            before repacking
        -->
        <echo message="Codesigning all applicationinsights-agent .jnilib files"/>
        <antcall target="unpack-applicationinsights"/>
        <apply executable="/usr/bin/codesign" parallel="false" os="Mac OS X" failonerror="true">
            <arg value="-v"/>
            <arg value="-f"/>
            <arg value="--options"/>
            <arg value="runtime"/>
            <arg value="--entitlements"/>
            <arg value="${sc.basedir}/resources/install/macosx/entitlements.xml"/>
            <arg value="-s"/>
            <arg value="${macosx.sign.certid}"/>
            <arg value="--timestamp"/>
            <srcfile/>
            <fileset dir="${macosx.app.dir}/${application.name.ascii}.app/Contents/Java/ApplicationInsights"
                     includes="**/*.jnilib"/>
        </apply>
        <antcall target="purge-applicationsinisghts-signatures"/>
        <antcall target="repack-applicationinsights"/>

        <echo message="Codesigning Sparkle/.../finish_installation.app/.../Autoupdate"/>
        <exec executable="/usr/bin/codesign" os="Mac OS X" failonerror="true">
            <arg value="-f"/>
            <arg value="-s"/>
            <arg value="${macosx.sign.certid}"/>
            <arg value="-o"/>
            <arg value="runtime"/>
            <arg value="--generate-entitlement-der"/>
            <arg value="${macosx.app.dir}/${application.name.ascii}.app/Contents/Frameworks/Sparkle.framework/Versions/B/Autoupdate"/>
        </exec>

        <echo message="Codesigning Sparkle/.../finish_installation.app/.../Updater.app"/>
        <exec executable="/usr/bin/codesign" os="Mac OS X" failonerror="true">
            <arg value="-f"/>
            <arg value="-s"/>
            <arg value="${macosx.sign.certid}"/>
            <arg value="-o"/>
            <arg value="runtime"/>
            <arg value="--generate-entitlement-der"/>
            <arg value="${macosx.app.dir}/${application.name.ascii}.app/Contents/Frameworks/Sparkle.framework/Versions/B/Updater.app"/>
        </exec>

        <echo message="Codesigning Sparkle.framework"/>
        <exec executable="/usr/bin/codesign" os="Mac OS X" failonerror="true">
            <arg value="-f"/>
            <arg value="-s"/>
            <arg value="${macosx.sign.certid}"/>
            <arg value="-o"/>
            <arg value="runtime"/>
            <arg value="${macosx.app.dir}/${application.name.ascii}.app/Contents/Frameworks/Sparkle.framework"/>
        </exec>

        <!-- signing the entire application -->
        <echo message="!About to run: codesign -v --deep -f --options runtime --entitlements ${sc.basedir}/resources/install/macosx/entitlements.xml -s ${macosx.sign.certid} ${macosx.app.dir}/${application.name.ascii}.app"/>
        <exec executable="/usr/bin/codesign" os="Mac OS X" failonerror="true">
            <arg value="-v"/>
            <arg value="--deep"/>
            <arg value="-f"/>
            <arg value="--options"/>
            <arg value="runtime"/>
            <arg value="--entitlements"/>
            <arg value="${sc.basedir}/resources/install/macosx/entitlements.xml"/>
            <arg value="-s"/>
            <arg value="${macosx.sign.certid}"/>
            <arg value="--generate-entitlement-der"/>
            <arg value="${macosx.app.dir}/${application.name.ascii}.app"/>
        </exec>

        <!-- just print sign info
            To test is sign accepted do $ sudo spctl -a -v -->
        <exec executable="/usr/bin/codesign" os="Mac OS X" failonerror="true">
            <arg value="-dvvv"/>
            <arg value="${macosx.app.dir}/${application.name.ascii}.app"/>
        </exec>

        <!-- Lock the keychain again -->
        <antcall target="macosx-lock-keychain"/>
    </target>

    <target name="macosx-sparkle-files" if="env.SPARKLE_EDDSA_KEY">
        <!-- Now is as good a time as any to delete files from the sparkle_generate_app cache, which quickly takes up a huge space -->
        <mkdir dir="~/Library/Caches/Sparkle_generate_appcast"/>
        <exec executable="/bin/sh" failonerror="true">
            <arg value="-c" />
            <arg value="find ~/Library/Caches/Sparkle_generate_appcast -maxdepth 1 -name '*.dmg' -mtime +1 -exec rm -rf {} \;" />
        </exec>

        <!-- Create basic appcast file using Sparkle's generate_appcast tool -->
        <exec executable="${ext}/scripts/generate_appcast" os="Mac OS X" failonerror="true">
            <arg value="--ed-key-file"/>
            <arg value="${env.SPARKLE_EDDSA_KEY}"/>
            <arg value="${macosx.app.dir}"/>
        </exec>

        <!-- Determine filename of the appcast that generate_appcast wrote.
            If the .app has a well-formed feed url in its Info.plist (equivalent to ${link.updates.macosx}),
            generate_appcast uses the basename of that, otherwise it defaults to "appcast.xml".
            If a file with the first filename exists, use that, otherwise use appcast.xml -->
        <basename property="possible.appcast.file" file="${link.updates.macosx}"/>
        <condition property="sparkle.appcast.file" value="${possible.appcast.file}" else="appcast.xml">
            <available file="${macosx.app.dir}/${possible.appcast.file}"/>
        </condition>

        <!-- Load xml properties from the appcast file so we can reuse the timestamp -->
        <xmlproperty file="${macosx.app.dir}/${sparkle.appcast.file}" prefix="appcast"/>
        <property name="sparkle.timestamp" value="${appcast.rss.channel.item.pubDate}"/>

        <!-- If ${link.download.macosx} contains the string literal ${package.name} (true for dev branding)
             replace it with the value of ${package.name.despaced} in the download link, otherwise
             keep the original download link -->
        <propertyregex property="link.download.macosx.expanded"
                       input="${link.download.macosx}"
                       regexp="\$\{package.name\}"
                       replace="${package.name.despaced}"
                       defaultvalue="${link.download.macosx}"/>

        <!-- Replace minimumSystemVersion to 10.13 (Sparkle 2.3.0 requires macOS 10.13+/Xcode 14+) -->
        <property name="sparkle.minsysversion" value="10.13"/>
        <replaceregexp file="${macosx.app.dir}/${sparkle.appcast.file}"
                       match="minimumSystemVersion&gt;.*&lt;"
                       replace="minimumSystemVersion&gt;${sparkle.minsysversion}&lt;"/>

        <!-- Replace download link in appcast (value of url attribute) with full path to dmg-->
        <replaceregexp file="${macosx.app.dir}/${sparkle.appcast.file}"
                       match="url=&quot;.*?&quot;"
                       replace="url=&quot;${link.download.macosx.expanded}&quot;"/>

        <!-- Add changelog section (not used by Sparkle) -->
        <replace file="${macosx.app.dir}/${sparkle.appcast.file}">
            <replacetoken><![CDATA[<channel>]]></replacetoken>
            <replacevalue expandproperties="true"><![CDATA[<channel>
        <title>Changelog</title>
        <link>${link.updates.macosx}</link>
        <description>Build ${sparkle.build} for MacOSX generated on ${sparkle.timestamp}.</description>
        <language>en</language>]]></replacevalue>
        </replace>

        <!-- Add Sparkle deltas section -->
        <replace file="${macosx.app.dir}/${sparkle.appcast.file}">
            <replacetoken><![CDATA[</item>]]></replacetoken>
            <replacevalue><![CDATA[    <sparkle:deltas>
            @SPARKLE_DELTAS@
            </sparkle:deltas>
        </item>]]></replacevalue>
        </replace>

        <!-- Create index.html changelog file -->
        <filter token="BUILD" value="${sparkle.build}" />
        <filter token="DATE" value="${sparkle.timestamp}" />
        <filter token="APP_NAME" value="${application.name.ascii}" />

        <copy file="${macosx.resrc.dir}/sparkle-files/index-top.html"
              todir="${macosx.app.dir}/sparkle"
                overwrite="true" filtering="yes"/>

        <!-- Load a default value if file with changelogs is missing -->
        <condition property="latest.changelog" value="Nightly builds">
            <not>
                <isset property="latest.changelog"/>
            </not>
        </condition>

        <concat destfile="${macosx.app.dir}/sparkle/index.html">
            <fileset dir="${macosx.app.dir}/sparkle">
                <include name="index-top.html"/>
            </fileset>
            <propertyset>
                <propertyref name="latest.changelog"/>
            </propertyset>
            <fileset dir="${macosx.resrc.dir}/sparkle-files">
                <include name="index-bottom.html"/>
            </fileset>
        </concat>
        <delete file="${macosx.app.dir}/sparkle/index-top.html"/>
        <delete file="changelog-${label}.html"/>
    </target>

    <!-- task only finishes generating sparkle files if needed -->
    <target name="macosx-sparkle-files-finish"
            if="env.SPARKLE_EDDSA_KEY">
        <!-- To be able to insert deltas in the updates xml
            we use the token @SPARKLE_DELTAS@. And when finished
            putting deltas (no matter if there were any at all if option
            is not enabled) we must remove the SPARKLE_DELTAS token if left.
        -->
        <filter token="SPARKLE_DELTAS" value="" />
        <move file="${macosx.app.dir}/${sparkle.appcast.file}"
              tofile="${macosx.app.dir}/sparkle/${filename.updates.macosx}"
              overwrite="true" filtering="yes"/>
    </target>

    <target name="macosx-sparkle-delta-updates"
            if="delta.history.location"
            depends="buildtools.init-ant-contrib" >

        <!-- create temp dir for making delta diffs -->
        <mkdir dir="${macosx.app.dir}/tmp"/>

        <!-- Attach the current image -->
        <exec executable="/usr/bin/hdiutil" os="Mac OS X" failonerror="true">
            <arg value="attach"/>
            <arg value="${macosx.app.dir}/${macosx.dmg.name}"/>
            <arg value="-mountroot"/>
            <arg value="${macosx.app.dir}/tmp"/>
        </exec>

        <unzip src="${macosx.resrc.dir}/Sparkle.framework.zip"
               dest="${macosx.app.dir}/tmp"/>
        <copy file="${macosx.resrc.dir}/BinaryDelta"
              todir="${macosx.app.dir}/tmp"/>
        <chmod file="${macosx.app.dir}/tmp/BinaryDelta"
               perm="ugo+rx"/>


        <!-- Find all previous builds we have to build deltas for them -->
        <foreach param="build-location" target="-make-sparkle-delta"
                 inheritall="true" inheritrefs="true">
            <path>
                <dirset dir="${delta.history.location}">
                    <include name="*"/>
                </dirset>
            </path>
        </foreach>

        <!-- Detach the temporary image -->
        <exec executable="/usr/bin/hdiutil" os="Mac OS X" failonerror="true">
            <arg value="detach"/>
            <arg value="${macosx.app.dir}/tmp/${application.name.ascii}"/>
        </exec>

        <!-- delete the temp dir -->
        <delete dir="${macosx.app.dir}/tmp"/>

        <!-- copy data for next delta builds-->
        <mkdir dir="${delta.history.location}/${sparkle.build}"/>
        <copy file="${macosx.app.dir}/${macosx.dmg.name}"
              tofile="${delta.history.location}/${sparkle.build}/${package.name.despaced}.dmg"/>

        <!-- now delete old one -->
        <antcall target="-delete-oldest-delta-data"/>
    </target>

    <target name="-make-sparkle-delta">

        <basename property="old.sparkle.build" file="${build-location}"/>
        <echo message="Creating dmg delta for ${old.sparkle.build}-${sparkle.build}"/>


        <!-- create temp dir for making delta diffs -->
        <mkdir dir="${macosx.app.dir}/tmp/${old.sparkle.build}"/>

        <!-- Attach the  image -->
        <exec executable="/usr/bin/hdiutil" os="Mac OS X" failonerror="true">
            <arg value="attach"/>
            <arg value="${build-location}/${package.name.despaced}.dmg"/>
            <arg value="-mountroot"/>
            <arg value="${macosx.app.dir}/tmp/${old.sparkle.build}"/>
        </exec>

        <!-- make the actual diff -->
        <exec executable="${macosx.app.dir}/tmp/BinaryDelta"
              os="Mac OS X" failonerror="true">
            <arg value="create"/>
            <arg value="${macosx.app.dir}/tmp/${old.sparkle.build}/${application.name.ascii}/${application.name.ascii}.app"/>
            <arg value="${macosx.app.dir}/tmp/${application.name.ascii}/${application.name.ascii}.app"/>
            <arg value="${macosx.app.dir}/${application.name.ascii}-${old.sparkle.build}-to-${sparkle.build}.delta"/>
        </exec>

        <!-- Detach the temporary image -->
        <exec executable="/usr/bin/hdiutil" os="Mac OS X" failonerror="true">
            <arg value="detach"/>
            <arg value="${macosx.app.dir}/tmp/${old.sparkle.build}/${application.name.ascii}"/>
        </exec>

        <!-- delete the temp dir -->
        <delete dir="${macosx.app.dir}/tmp/${old.sparkle.build}"/>

        <exec executable="bash" os="Mac OS X" failonerror="true"
              outputproperty="delta.signature.base64">
            <arg value="-c"/>
            <arg value="openssl dgst -sha1 -binary &lt; '${macosx.app.dir}/${application.name.ascii}-${old.sparkle.build}-to-${sparkle.build}.delta' | openssl dgst -dss1 -sign ${env.SPARKLE_EDDSA_KEY} | openssl enc -base64"/>
        </exec>

        <length file="${macosx.app.dir}/${application.name.ascii}-${old.sparkle.build}-to-${sparkle.build}.delta"
                property="delta.file.length" />

        <!-- Copy the file to a temporary location and then move it back again so we can use filtering to replace
            the SPARKLE_DELTAS token with the correct xml -->
        <copy file="${macosx.app.dir}/${sparkle.appcast.file}"
              tofile="${macosx.app.dir}/${sparkle.appcast.file}-tmp.xml"/>
        <move file="${macosx.app.dir}/${sparkle.appcast.file}-tmp.xml"
                tofile="${macosx.app.dir}/${sparkle.appcast.file}"
                overwrite="true" filtering="yes">

          <filterset recurse="false">
            <filter token="SPARKLE_DELTAS" value="
              &lt;enclosure type=&quot;application/octet-stream&quot;
              sparkle:version=&quot;${sparkle.build}&quot; length=&quot;${delta.file.length}&quot;
              sparkle:dsaSignature=&quot;${delta.signature.base64}&quot;
              sparkle:deltaFrom=&quot;${old.sparkle.build}&quot;
              url=&quot;${sparkle.delta.download.location}/${application.name.ascii}-${old.sparkle.build}-to-${sparkle.build}.delta&quot;/&gt;
              @SPARKLE_DELTAS@
            " />
          </filterset>
        </move>
    </target>

    <target name="-delete-oldest-delta-data">
        <resourcecount property="build.history.current.size">
            <dirset dir="${delta.history.location}">
                <include name="*"/>
            </dirset>
        </resourcecount>
        <math result="build.history.to.delete"
            operand1="${build.history.current.size}"
            operation="-"
            operand2="${delta.history.size}"
            datatype="int"/>

        <timestampselector outputsetid="oldest.builds"
                        count="${build.history.to.delete}"
                        age="eldest">
          <path>
             <dirset dir="${delta.history.location}">
               <include name="*" />
             </dirset>
          </path>
        </timestampselector>

        <foreach param="build.to.delete"
                 target="-delete-oldest-delta-data-folder">
            <path refid="oldest.builds"/>
        </foreach>
    </target>
    <target name="-delete-oldest-delta-data-folder">
        <echo message="!!! Deleting old data dir ${build.to.delete} !!! " />
        <delete dir="${build.to.delete}" failonerror="false"/>
    </target>

    <!-- Mac helper targets -->

    <!-- Unlock the login keychain on mac and set a long timeout (1200 seconds i.e. 20 minutes) -->
    <target name="macosx-unlock-keychain">
        <exec executable="/usr/bin/security" os="Mac OS X" failonerror="true">
            <arg value="unlock-keychain"/>
            <arg value="-p"/>
            <arg value="${macosx.sign.password}"/>
            <arg value="${macosx.sign.keychain}"/>
        </exec>

        <exec executable="/usr/bin/security" os="Mac OS X" failonerror="true">
            <arg value="set-keychain-settings"/>
            <arg value="-t"/>
            <arg value="1800"/>
            <arg value="${macosx.sign.keychain}"/>
        </exec>
    </target>

    <!-- Lock the login keychain on mac-->
    <target name="macosx-lock-keychain">
        <exec executable="/usr/bin/security" os="Mac OS X" failonerror="true">
            <arg value="lock-keychain"/>
            <arg value="${macosx.sign.keychain}"/>
        </exec>
    </target>

    <!--
        Construct the mac app's bundle identifier
        The bundle identifier must always stay consistent with its original value, even after app rename.
        Bundle identifiers should not contain spaces, but some of the packagenames historically did, and we cannot change that.
        We continue to set the bundle.identifier using the value in package.name, not the despaced one, and hope that
        various tools simply handle the invalid bundle id in a consistent way.
    -->
    <target name="bundle-identifier">
        <condition property="bundle.identifier" value="org.${package.name}" else="org.${package.name.original}">
            <equals arg1="${package.name.original}" arg2=""/>
        </condition>
    </target>

    <target name="unpack-applicationinsights" >
        <property name="content.root" value="${macosx.app.dir}/${application.name.ascii}.app/Contents/Java"/>

        <echo message="Unpacking application insights for signing"/>
        <unzip dest="${content.root}/ApplicationInsights">
            <fileset file="${content.root}/applicationinsights-agent.jar"
            includes="**/*.jnilib"/>
        </unzip>
    </target>

    <!-- Repacking also recreates the manifest for the agent -->
    <target name="repack-applicationinsights" >
        <property name="content.root" value="${macosx.app.dir}/${application.name.ascii}.app/Contents/Java"/>

        <echo message="Repacking application insights..."/>
        <delete file="${content.root}/applicationinsights-agent.jar" />
        <jar destfile="${content.root}/applicationinsights-agent.jar"
            basedir="${content.root}/ApplicationInsights"
            update="false">
            <manifest>
                <attribute name="Premain-Class" value="com.microsoft.applicationinsights.agent.Agent" />
                <attribute name="Agent-Class" value="com.microsoft.applicationinsights.agent.Agent" />
                <attribute name="Can-Redefine-Classes" value="true" />
                <attribute name="Can-Retransform-Classes" value="true" />
            </manifest>
        </jar>
        <delete dir="${content.root}/ApplicationInsights" />
    </target>

    <target name="purge-applicationsinisghts-signatures">
        <delete>
            <fileset dir="${macosx.app.dir}/${application.name.ascii}.app/Contents/Java/ApplicationInsights">
                <include name="**/MSFTSIG.RSA"/>
                <include name="**/MSFTSIG.SF"/>
            </fileset>
        </delete>
    </target>
</project>
